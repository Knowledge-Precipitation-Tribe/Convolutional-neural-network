# 多通道卷积

多通道卷积过程如下，每个kernel都应用于前一层的输入通道，以生成一个输出通道。我们对所有kernel重复这个过程以生成多个通道。然后将这些通道汇总在一起，形成一个单独的输出通道。

这里的输入层是一个5×5×3的矩阵，有3个通道。filter是一个3×3×3矩阵。首先，filter中的每个kernel分别应用于输入层中的三个通道。执行三个卷积，得到3个通道，大小为3 x 3。

![&#x591A;&#x901A;&#x9053;2D&#x5377;&#x79EF;&#x7684;&#x7B2C;&#x4E00;&#x6B65;&#xFF1A;&#x5C06;filter&#x4E2D;&#x7684;&#x6BCF;&#x4E2A;kernel&#x5206;&#x522B;&#x5E94;&#x7528;&#x4E8E;&#x8F93;&#x5165;&#x5C42;&#x4E2D;&#x7684;&#x4E09;&#x4E2A;&#x901A;&#x9053;&#x3002;](../.gitbook/assets/multi-channel.gif)

在5\*5矩阵上执行遍历的就是每一个kernel。然后这三个输出的通道相加\(元素相加\)形成一个单独的通道\(3 x 3 x 1\)。这个最终的单通道是使用filter\(3 x 3 x 3矩阵\)对输入层\(5 x 5 x 3矩阵\)进行卷积的结果。

![&#x591A;&#x901A;&#x9053;2D&#x5377;&#x79EF;&#x7684;&#x7B2C;&#x4E8C;&#x6B65;&#xFF1A;&#x7136;&#x540E;&#x5C06;&#x8FD9;&#x4E09;&#x4E2A;&#x901A;&#x9053;&#x52A0;&#x5728;&#x4E00;&#x8D77;&#xFF08;&#x9010;&#x5143;&#x7D20;&#x52A0;&#x6CD5;&#xFF09;&#x4EE5;&#x5F62;&#x6210;&#x4E00;&#x4E2A;&#x5355;&#x4E2A;&#x901A;&#x9053;&#x3002;](../.gitbook/assets/multi-channel1.gif)

{% hint style="info" %}
输入层的通道数和filter的kernel数量是相等的
{% endhint %}

等效地，我们可以认为此过程是将3Dfilter矩阵滑过输入层。请注意，输入层和filter的深度相同（通道号=内核号）。3D filter 只能在图像的2个方向，高度和宽度上移动（这就是为什么这种操作被称为2D卷积的原因，尽管3D filter 用于处理3D体积数据）。在每个滑动位置，我们执行逐元素的乘法和加法运算，结果为单个数字。在以下示例中，滑动在水平5个位置和垂直5个位置进行。总的来说，我们得到一个输出通道。

![](../.gitbook/assets/image%20%28119%29.png)

思考2​​D卷积的另一种方法：将过程视为将3D filter 矩阵滑过输入层。请注意，输入层和过滤器的深度相同（通道号=内核号）。3D filter 只能在图像的2个方向，高度和宽度上移动（这就是为什么这种操作被称为2D卷积的原因，尽管3D滤镜用于处理3D体积数据）。输出是一层矩阵。

现在我们可以看到如何在不同深度的图层之间进行变换。假设输入层具有Din通道，而我们希望输出层具有Dout通道。我们需要做的只是将Dout 个filter应用于输入层。每个filter都有Din个kernel。每个filter提供一个输出通道。应用Dout滤镜后，我们将拥有Dout通道，然后可以将它们堆叠在一起以形成输出层。

![&#x6807;&#x51C6;2D&#x5377;&#x79EF;&#x3002;&#x4F7F;&#x7528;Dout&#x4E2A;filter &#x5C06;&#x6DF1;&#x5EA6;&#x4E3A;Din&#x7684;&#x4E00;&#x5C42;&#x6620;&#x5C04;&#x5230;&#x6DF1;&#x5EA6;&#x4E3A;Dout&#x7684;&#x53E6;&#x4E00;&#x5C42;&#x3002;](../.gitbook/assets/image%20%28125%29.png)

